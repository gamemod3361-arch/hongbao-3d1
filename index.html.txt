<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>紅包 3D 互動預覽</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background:#0b0b0b; }
    #ui {
      position: fixed; left: 12px; top: 12px; z-index: 10;
      color: #fff; font: 14px/1.4 system-ui, -apple-system, "PingFang TC", "Noto Sans TC", sans-serif;
      background: rgba(0,0,0,.45); padding: 10px 12px; border-radius: 10px;
      backdrop-filter: blur(6px);
      max-width: 320px;
    }
    #ui kbd { background: rgba(255,255,255,.15); padding: 2px 6px; border-radius: 6px; }
    a { color:#9ad; }
  </style>
</head>
<body>
  <div id="ui">
    <div><b>操作</b></div>
    <div>拖曳：旋轉　滾輪：縮放　右鍵拖：平移</div>
    <div>點一下紅包：掀蓋/闔上</div>
    <div style="opacity:.8;margin-top:6px;">貼圖檔：<kbd>texture.jpg</kbd>（放同資料夾）</div>
  </div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
    import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";

    
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0b0b0b, 4, 18);

    const camera = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, 0.01, 100);
    camera.position.set(0, 1.6, 6);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    
    const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 0.9);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 1.2);
    dir.position.set(3, 5, 2);
    dir.castShadow = false;
    scene.add(dir);

    
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(60, 60),
      new THREE.MeshStandardMaterial({ color: 0x0b0b0b, roughness: 0.95, metalness: 0.0 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -1.2;
    scene.add(ground);

    
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(0, 0.4, 0);
    controls.minDistance = 2.2;
    controls.maxDistance = 12;

    
    const loader = new THREE.TextureLoader();
    const texture = await new Promise((resolve, reject) => {
      loader.load(
        "./texture.jpg.PNG",
        t => resolve(t),
        undefined,
        e => reject(e)
      );
    });
    texture.colorSpace = THREE.SRGBColorSpace;
    texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
    texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;

    
    const W = 3.2, H = 4.6, T = 0.18;

    
    const redMat = new THREE.MeshStandardMaterial({ color: 0xb2181d, roughness: 0.75, metalness: 0.05 });

    
    const texMat = new THREE.MeshStandardMaterial({ map: texture, roughness: 0.85, metalness: 0.0 });
    const materials = [
      redMat, // right
      redMat, // left
      redMat, // top
      redMat, // bottom
      texMat, // front
      texMat  // back
    ];

    const body = new THREE.Mesh(new THREE.BoxGeometry(W, H, T), materials);
    body.position.set(0, 0.2, 0);
    scene.add(body);
    const flapH = 1.5;          
    const flapW = W * 0.98;     
    const flapGeo = new THREE.PlaneGeometry(flapW, flapH);
    const flapMat = new THREE.MeshStandardMaterial({
      color: 0xb2181d,
      roughness: 0.7,
      metalness: 0.05,
      side: THREE.DoubleSide
    });

    const flap = new THREE.Mesh(flapGeo, flapMat);

    
    const flapPivot = new THREE.Object3D();
    flapPivot.position.set(0, body.position.y + H/2 - 0.02, T/2 + 0.001);
    scene.add(flapPivot);

    
    flap.position.set(0, -flapH/2, 0);
    flapPivot.add(flap);

    
    flapPivot.rotation.x = 0;

    
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let isOpen = false;
    let animT = 0; // 0~1
    let animFrom = 0;
    let animTo = 0;

    function onPointerDown(ev) {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -(((ev.clientY - rect.top) / rect.height) * 2 - 1);

      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObjects([body, flap], true);
      if (hits.length) {
        
        isOpen = !isOpen;
        animT = 0;
        animFrom = flapPivot.rotation.x;
        animTo = isOpen ? -Math.PI * 0.85 : 0; 
      }
    }
    window.addEventListener("pointerdown", onPointerDown);

    
    window.addEventListener("resize", () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    });

    
    body.rotation.y = Math.PI * 0.08;

    
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.033);

      
      if (animT < 1) {
        animT = Math.min(1, animT + dt * 3.2);
        const t = animT * animT * (3 - 2 * animT); // smoothstep
        flapPivot.rotation.x = THREE.MathUtils.lerp(animFrom, animTo, t);
      }

      controls.update();
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
